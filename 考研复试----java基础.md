[Java基础常见面试题总结(上) | JavaGuide(Java面试+学习指南)](https://javaguide.cn/java/basis/java-basic-questions-01.html)



### Java 语言有哪些特点?

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
5. 可靠性；
6. 安全性；
7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

------

###  Java 和 C++ 的区别?

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

------

#### 静态变量有什么作用？

静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。

通常情况下，静态变量会被 `final` 关键字修饰成为常量。

---



**注意： `char` 在 Java 中占两个字节**

---

 **重载和重写有什么区别？**

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**重载**

发生在同一个类中（或者父类和子类之间），**方法名必须相同**，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

《Java 核心技术》这本书是这样介绍重载的：

> 如果多个方法(比如 `StringBuilder` 的构造方法)有相同的名字、不同的参数， 便产生了重载。
>
> 
>
> ```java
> StringBuilder sb = new StringBuilder();
> StringBuilder sb2 = new StringBuilder("HelloWorld");
> ```
>
> 编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。
>
> Java 允许重载任何方法， 而不只是构造器方法。

综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

**重写**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

| 区别点     | 重载方法 |                           重写方法                           |
| :--------- | :------- | :----------------------------------------------------------: |
| 发生范围   | 同一个类 |                             子类                             |
| 参数列表   | 必须修改 |                         一定不能修改                         |
| 返回类型   | 可修改   |      子类方法返回值类型应比父类方法返回值类型更小或相等      |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   |            一定不能做更严格的限制（可以降低限制）            |
| 发生阶段   | 编译期   |                            运行期                            |

**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》，[issue#892open in new window](https://github.com/Snailclimb/JavaGuide/issues/892) ）：

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

⭐️ 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。



```java
public class Hero {
    public String name() {
        return "超级英雄";
    }
}
public class SuperMan extends Hero{
    @Override
    public String name() {
        return "超人";
    }
    public Hero hero() {
        return new Hero();
    }
}

public class SuperSuperMan extends SuperMan {
    public String name() {
        return "超级超级英雄";
    }

    @Override
    public SuperMan hero() {
        return new SuperMan();
    }
}
```

------

### Java 中的几种基本数据类型了解么？

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

------

这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`

---

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

举例：



```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

上面这两行代码对应的字节码为：



```java
   L1

    LINENUMBER 8 L1

    ALOAD 0

    BIPUSH 10

    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;

    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;

   L2

    LINENUMBER 9 L2

    ALOAD 0

    ALOAD 0

    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;

    INVOKEVIRTUAL java/lang/Integer.intValue ()I

    PUTFIELD AutoBoxTest.n : I

    RETURN
```

从字节码中，我们发现装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

因此，

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`;

注意：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

------

### 面向对象和面向过程的区别

两者的主要区别在于解决问题的方式不同：

- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

另外，面向对象开发的程序一般更易维护、易复用、易扩展。

------

### 类的构造方法的作用是什么?

构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。

---

### 构造方法有哪些特点？是否可被 override?

构造方法特点如下：

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

------

### 面向对象三大特征

#### [#](#封装) 封装

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。

```java
public class Student {
    private int id;//id属性私有化
    private String name;//name属性私有化

    //获取id的方法
    public int getId() {
        return id;
    }

    //设置id的方法
    public void setId(int id) {
        this.id = id;
    }

    //获取name的方法
    public String getName() {
        return name;
    }

    //设置name的方法
    public void setName(String name) {
        this.name = name;
    }
}
```

#### [#](#继承) 继承

不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

#### [#](#多态) 多态

多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

**多态的特点:**

- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用“只在子类存在但在父类不存在”的方法；
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法

------

### 接口和抽象类有什么共同点和区别？

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

------

### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

关于深拷贝和浅拷贝区别，我这里先给结论：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

------

#### == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

------

### String, StringBuffer and StringBuilder

   **1. 可变性**

   - String 不可变
   - StringBuffer 和 StringBuilder 可变

   **2. 线程安全**

   - String 不可变，因此是线程安全的
   - StringBuilder 不是线程安全的
   - StringBuffer 是线程安全的，内部使用 synchronized 进行同步

---

###  try-catch-finally 如何使用？

- `try`块 ： 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
- `catch`块 ： 用于处理 try 捕获到的异常。
- `finally` 块 ： 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

------

### Exception 和 Error 有什么区别？

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

------

#### 泛型？

- Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。

------

### 反射

关于反射的详细解读，请看这篇文章 [Java 反射机制详解](https://javaguide.cn/java/basis/reflection.html)

通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性

**反射的优点：**

- **可扩展性** ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境** ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具** ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

**反射的缺点：**

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销** ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

---

#### Java IO 流了解吗？

IO 即 `Input/Output`，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

------

#### Java中只有值传递没有引用传递



------

1. #### 什么是Java虚拟机（JVM）？请简单介绍一下JVM的工作原理。

   > Java虚拟机（JVM）是Java平台的核心组件之一，它是一种能够在不同操作系统上运行Java字节码的虚拟计算机。
   >
   > JVM的工作原理大致如下：首先，Java源代码被编译成字节码文件（即.class文件），然后JVM读取这些字节码文件并将其转换为本地机器代码，以在特定的操作系统和硬件上执行Java程序。JVM还负责内存管理、垃圾回收和安全性检查等任务。
   >
   > JVM的工作流程主要分为以下几个步骤： 1.类加载：JVM在运行Java程序之前需要将程序中所有的类文件加载到内存中。类加载器将类文件加载到JVM中，并生成类的Class对象。 2.字节码解释和验证：JVM将字节码解释为机器指令，并且在执行前会对字节码进行验证，以确保其安全性。 3.即时编译：JVM将经常执行的字节码编译为本地机器代码，以提高程序的执行效率。 4.垃圾回收：JVM负责内存的分配和释放，同时也会自动进行垃圾回收，以避免内存泄漏和内存溢出等问题。
   >
   > 总之，JVM是Java语言跨平台的重要保障，通过JVM可以将Java程序编写一次，在不同平台上运行，大大提高了Java语言的可移植性。

2. #### Java中的常量池是什么？它有什么作用？

   > Java中的常量池是一种存储常量的机制，它可以在编译时或运行时进行常量的存储和管理。常量池可以分为两种：编译时常量池和运行时常量池。
   >
   > 编译时常量池是指在编译阶段，Java编译器将所有的字面量和符号引用都存储到常量池中。例如，字符串、整数、浮点数等字面量，以及类、方法、字段等符号引用都可以被存储到常量池中。在类加载时，这些常量将被加载到运行时常量池中。
   >
   > 运行时常量池是指在程序运行期间，类加载器将编译时常量池中的常量加载到内存中，并进行动态的修改和更新。运行时常量池的作用包括提高程序的性能和减少内存的使用。
   >
   > 常量池的作用在于避免重复创建相同的常量对象，从而节省内存空间。在程序运行期间，常量池中的常量可以被多个线程共享，从而提高了程序的性能。

3. #### 什么是Java反射（Reflection）？请说明反射的作用以及如何使用反射机制。

   > Java反射（Reflection）是Java的一个强大特性，它允许程序在运行时动态地获取类的信息、构造对象、调用方法以及访问和修改变量等。反射机制在Java语言中广泛应用于编写各种框架、插件和工具等。
   >
   > 反射的主要作用包括：
   >
   > 1. 动态获取类的信息：反射机制可以在运行时获取类的各种信息，如类的名称、父类、接口、构造方法、成员变量、方法等，这样可以避免在编译时就硬编码类的信息。
   > 2. 动态构造对象：反射机制可以在运行时动态构造一个对象，而不需要在编译时就确定对象的类型。这种动态构造对象的方式可以极大地提高程序的灵活性和扩展性。
   > 3. 动态调用方法和修改变量：反射机制可以在运行时动态调用对象的方法和访问和修改对象的成员变量，这样可以避免在编译时就硬编码方法和变量的名称和类型。
   >
   > 如何使用反射机制呢？反射机制的使用主要包括以下几个步骤：
   >
   > 1. 获取Class对象：可以通过以下方式获取Class对象：
   >
   >    a. 调用对象的getClass()方法获取Class对象。
   >
   >    b. 调用Class类的静态方法forName()获取Class对象。
   >
   >    c. 直接使用类名.class获取Class对象。
   >
   > 2. 创建对象：可以通过Class对象的newInstance()方法或者Constructor对象的newInstance()方法创建对象。
   >
   > 3. 调用方法：可以通过Method对象的invoke()方法调用对象的方法。
   >
   > 4. 访问和修改变量：可以通过Field对象的get()和set()方法访问和修改对象的成员变量。
   >
   > 需要注意的是，由于反射机制会在运行时进行类型检查，因此会带来一定的性能损失。另外，在使用反射机制时需要注意安全问题，如要对反射机制进行访问权限的控制。

4. #### 请简单介绍一下Java中的集合框架（Collection Framework），并说明其中的常用类和接口。

   > Java中的集合框架是一组接口、实现类和算法，用于表示和操作集合。集合框架提供了一组数据结构，比如列表（List）、集合（Set）、映射（Map）等，以及一些辅助的接口和类。
   >
   > 常用的集合类和接口如下：
   >
   > 1. List：一个有序的元素集合，元素可以重复，可以根据下标访问。常用的实现类有 ArrayList、LinkedList 和 Vector。
   > 2. Set：一个不重复元素的集合。常用的实现类有 HashSet、LinkedHashSet 和 TreeSet。
   > 3. Map：一种映射关系，可以将键映射到值。常用的实现类有 HashMap、LinkedHashMap 和 TreeMap。
   > 4. Queue：一个元素先进先出（FIFO）的集合。常用的实现类有 LinkedList、PriorityQueue 和 ArrayDeque。
   > 5. Stack：一个元素后进先出（LIFO）的集合。常用的实现类有 Stack。
   >
   > 集合框架中的接口有很多，其中一些常用的接口包括：
   >
   > 1. Collection：是所有集合类的基本接口，提供了一些通用的方法，比如添加、删除、遍历等操作。
   > 2. Iterator：迭代器接口，提供了一种访问集合元素的统一方式。
   > 3. ListIterator：列表迭代器接口，扩展了 Iterator 接口，提供了在 List 中双向移动的能力。
   > 4. Set、SortedSet：分别表示不重复元素的集合和有序的不重复元素的集合。
   > 5. Map、SortedMap：分别表示映射关系和有序的映射关系。

5. #### 什么是Java多线程编程？请说明Java多线程编程的优点和注意事项。

   > Java多线程编程是指在Java程序中同时运行多个线程以实现并发操作的编程方式。Java多线程编程的优点包括：
   >
   > 1. 提高程序的响应速度和并发性能：通过多线程编程可以让程序同时执行多个任务，提高程序的效率和响应速度。
   > 2. 提高资源利用率：多线程编程可以让CPU、内存等系统资源得到更好的利用。
   > 3. 程序结构清晰：多线程编程可以将程序分为多个独立的执行单元，使程序结构更加清晰。
   >
   > Java多线程编程需要注意以下几点：
   >
   > 1. 线程安全：多个线程同时访问共享资源时需要注意线程安全，避免出现数据竞争、死锁等问题。
   > 2. 死锁问题：在多线程编程中，如果不恰当地使用锁，可能会出现死锁问题，导致程序无法继续执行。
   > 3. 上下文切换开销：多线程编程需要进行线程切换，切换过程中会涉及上下文切换开销，需要注意控制线程数目，避免开销过大。
   >
   > Java中可以通过以下方式使用多线程：
   >
   > 1. 继承Thread类：通过继承Thread类并重写run()方法来创建线程。
   > 2. 实现Runnable接口：通过实现Runnable接口并实现run()方法来创建线程。
   > 3. 使用线程池：通过线程池来管理和控制多个线程的执行。
   >
   > 在多线程编程中需要注意同步问题，Java提供了synchronized关键字和Lock接口来实现同步，可以避免多个线程同时访问共享资源而引起的数据不一致问题。同时，Java中还提供了一些工具类，如CountDownLatch、CyclicBarrier、Semaphore等，来实现更加复杂的线程同步和协作操作

6. #### Java中的异常处理机制是什么？请简单介绍一下异常处理的基本原则和处理方式。

   > Java中的异常处理机制是一种用于处理程序执行过程中出现的异常情况的机制。异常可以是程序运行时错误、意外的情况或其他意外事件，它们可能导致程序终止或导致错误的输出结果。Java中的异常处理机制可以在程序中捕获这些异常并采取适当的措施来处理它们，以避免程序的异常终止或不稳定性。
   >
   > 异常处理的基本原则是将异常处理分离出来，使得程序的主体逻辑和异常处理逻辑分离。Java中使用try-catch-finally语句来处理异常。try块包含可能抛出异常的代码段，catch块捕获和处理异常，finally块则在try和catch块执行完毕后执行清理操作。通过使用try-catch语句，可以在程序中捕获并处理异常，从而避免程序的异常终止。
   >
   > Java中的异常分为受检异常（Checked Exceptions）和非受检异常（Unchecked Exceptions）。受检异常必须在方法声明中显式地声明并处理，否则会导致编译错误；非受检异常则不需要在方法声明中显式声明，也不需要强制处理。常见的异常类包括Exception类和RuntimeException类及其子类。
   >
   > 在异常处理中，通常可以采取以下方式处理异常：
   >
   > 1. 抛出异常：当发生异常时，程序可以通过throw语句将异常抛出，从而使调用方能够处理异常。
   > 2. 捕获异常：通过使用try-catch语句捕获异常，并在catch块中处理异常。
   > 3. 抛出和捕获异常：在方法中捕获异常，但无法处理时，可以使用throw语句将异常重新抛出，从而使调用方可以处理异常。
   > 4. 使用finally块：finally块中的代码始终会在try和catch块执行完毕后执行，无论是否发生异常，这使得在程序中释放资源和清理操作变得更加简单。
   >
   > Java多线程编程的优点在于可以提高程序的并发性能和响应能力，使得程序能够更好地利用多核处理器的性能。在使用多线程时，需要注意线程同步和共享资源的问题，避免线程之间的竞争和冲突。同时，在处理异常时也需要注意多线程环境下的异常处理，避免异常终止程序或导致不稳定性。

7. #### 请简单介绍一下Java中的IO流，以及它们的使用方式和区别。

   > Java中的IO流（Input/Output stream）是用于读取和写入数据的一种机制，它是以流（stream）的形式来实现的。在Java中，所有的输入输出操作都是通过流的方式进行的。
   >
   > Java中的IO流可以分为两种类型：字节流和字符流。字节流以字节为单位读写数据，常用的字节流类包括InputStream和OutputStream，另外还有一些用于处理数据的装饰类，如BufferedInputStream和DataOutputStream等。字符流以字符为单位读写数据，常用的字符流类包括Reader和Writer，另外还有一些用于处理数据的装饰类，如BufferedReader和PrintWriter等。
   >
   > 使用Java的IO流时，需要先创建一个流对象，并指定输入或输出的数据源，然后通过读写操作来处理数据。对于文件的读写，可以使用FileInputStream和FileOutputStream来创建字节流对象；也可以使用FileReader和FileWriter来创建字符流对象。
   >
   > 在使用Java的IO流时，需要注意一些问题，例如：数据的大小和类型，以及数据源的可靠性等。另外，为了提高IO的效率，还可以使用一些装饰类来优化流的读写操作，如BufferedInputStream和BufferedOutputStream。
   >
   > 总之，Java的IO流是非常强大和灵活的，可以满足各种数据处理需求。但是在使用时，需要考虑到数据源的特性和读写操作的效率等问题，以保证程序的正确性和效率。

8. #### Java中的注解（Annotation）是什么？它的作用和用法是什么？

   > Java中的注解（Annotation）是一种元数据，它可以提供关于程序代码的额外信息，这些信息可以被编译器、解释器或者其他工具读取和处理。注解通常用于在源代码中添加标记，以便在程序运行时可以对其进行特殊处理。
   >
   > 注解在Java中使用@符号表示，通常放置在代码声明的上面，可以用于类、方法、变量、参数等的声明。Java中提供了许多内置的注解，比如@Override、@Deprecated、@SuppressWarnings等，用户也可以自定义注解。
   >
   > 注解的作用包括：
   >
   > 1. 提供程序元素（类、方法、变量等）的元数据信息，这些信息可以在编译时、运行时或者其他工具的处理过程中被读取和使用；
   > 2. 通过注解可以实现某些特殊的功能，例如JUnit中的@Test注解用于标记测试方法；
   > 3. 注解可以作为编程的一种风格，让程序更加清晰、易读、易维护。
   >
   > 注解的使用方式：
   >
   > 1. 注解的声明需要使用Java中的@interface关键字；
   > 2. 注解的成员可以是基本类型、枚举类型、Class类型、注解类型或它们的数组类型；
   > 3. 注解的成员可以有默认值，可以使用default关键字来指定；
   > 4. 使用注解时需要使用@注解名称的方式，在需要添加注解的地方添加即可。
   >
   > 注解的使用场景比较广泛，例如：
   >
   > 1. JPA中的@Entity、@Table等注解用于标记实体类及其属性与数据库表之间的映射关系；
   > 2. Spring中的@Autowired、@Controller、@Service等注解用于实现依赖注入、声明Bean、实现控制反转等功能；
   > 3. Swagger中的@Api、@ApiOperation等注解用于自动生成API文档。
   >
   > 注解的使用需要注意以下事项：
   >
   > 1. 注解只是提供额外的元数据信息，不会影响程序的运行逻辑；
   > 2. 注解的使用需要考虑代码的可读性和可维护性，不应滥用；
   > 3. 注解的使用需要遵守注解的约定和规范，以保证代码的正确性。

10. #### 什么是Java的泛型（Generics）？请说明泛型的作用和使用方法。

    > Java泛型是指在编写代码时，不指定具体类型而是使用类型参数来代替具体类型的技术。它的作用是提高代码的复用性、可读性和安全性。
    >
    > 使用泛型可以避免在类型转换时出现编译时和运行时的异常，同时可以使代码更加灵活和可扩展。例如，定义一个泛型类或方法可以处理不同类型的数据，而不需要为每种类型都编写一个专门的类或方法。
    >
    > 泛型的基本用法是在类或方法定义时使用类型参数，使用时再传入具体类型。例如，定义一个泛型类：
    >
    > ```java
    > public class MyList<T> {
    >     private T[] array;
    >     // ...
    > }
    > ```
    >
    > 在使用时，可以传入具体类型：
    >
    > ```java
    > MyList<Integer> intList = new MyList<Integer>();
    > intList.add(1);
    > intList.add(2);
    > ```
    >
    > 这样就可以创建一个只能存储整数的列表。
    >
    > 除了泛型类，还有泛型接口和泛型方法。在使用时，可以通过通配符（wildcard）来限制泛型类型的范围，例如：
    >
    > ```java
    >  public static void printList(List<?> list) {
    >     for (Object item : list) {
    >         System.out.println(item);
    >     }
    > }
    > ```
    >
    > 这样就可以编写一个可以处理任何类型列表的方法。在使用时可以传入任何类型的List。
    >
    > 总之，泛型是Java中一种强大的语言特性，可以提高代码的可读性和安全性，减少类型转换的错误。
    
10. #### Java中的接口和抽象类有什么区别？在什么情况下应该使用接口，什么情况下应该使用抽象类

    > 接口和抽象类的主要区别在于：
    >
    > 1. 实现方式不同：接口通过实现来实现多态，而抽象类通过继承来实现多态。
    > 2. 方法实现不同：接口中的方法都是抽象的，没有实现，而抽象类可以包含具体实现的方法和抽象的方法。
    > 3. 实现数目不同：一个类可以实现多个接口，但只能继承一个抽象类。
    >
    > 在使用接口和抽象类时，应该考虑以下几个因素：
    >
    > 1. 是否需要一个约束性的机制：如果需要一组方法声明的约束机制，应该使用接口。
    > 2. 是否需要通用代码的实现：如果需要一些通用的代码实现，应该使用抽象类。
    > 3. 是否需要多重继承：如果需要多重继承，应该使用接口。
    > 4. 是否需要定义变量：如果需要定义变量，应该使用抽象类。

11. #### Java中的访问修饰符有哪些？它们的作用是什么？

    > 在Java中，访问修饰符是用来控制类、变量、方法和构造函数的访问级别的关键字。Java中共有四种访问修饰符，分别为：
    >
    > 1. public：公共的，任何地方都可以访问。
    > 2. protected：受保护的，只有本类、子类和同一个包中的类可以访问。
    > 3. default（也称为 package-private）：默认的，只有同一个包中的类可以访问。
    > 4. private：私有的，只有本类中可以访问。
    >
    > 它们的作用如下：
    >
    > - public：可以被任何类访问，用于对外提供公共的访问接口。
    > - protected：可以被本类、子类、同一个包中的类访问，用于保护内部数据和方法，同时也提供对子类的访问接口。
    > - default：可以被本类、同一个包中的类访问，用于隐藏类的实现细节。
    > - private：只能被本类访问，用于保护类的内部数据和方法，同时也隐藏类的实现细节。
    >
    > 需要注意的是，访问修饰符只能修饰类的成员（变量、方法、构造函数），不能修饰类本身。访问修饰符的使用可以提高代码的可读性和可维护性，同时也可以有效地控制类的访问权限。

12. #### 什么是Java中的垃圾回收机制？它的原理是什么？

    > 
    > Java中的垃圾回收机制指的是自动内存管理，也就是在程序运行过程中，由JVM自动回收不再被程序使用的内存空间，防止内存泄漏和程序崩溃。
    >
    > 垃圾回收机制的原理是通过跟踪程序运行时所使用的内存空间，确定哪些内存空间可以被释放。Java中的垃圾回收器会周期性地扫描堆内存中的对象，并标记出那些仍在使用的对象和那些可以被回收的对象，然后清除那些可以被回收的对象所占用的内存空间，以便给后续的对象使用。
    >
    > Java中的垃圾回收机制是基于JVM实现的，每个JVM实现可能会有不同的垃圾回收策略，如标记清除（Mark and Sweep）、标记整理（Mark and Compact）、复制算法（Copying）等。此外，开发人员也可以通过代码中的System.gc()方法来强制进行垃圾回收，但并不能保证一定会回收所有的垃圾对象，也会降低程序的性能。



