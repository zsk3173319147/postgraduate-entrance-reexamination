#      考研复试----专业课学习

## 数据结构

### 第一章

1. ***逻辑结构***分为**线性结构和非线性结构**
2. **存储结构**又被称为**物理结构**，主要有**顺序存储、链式存储、索引存储、散列存储**。
3. 算法的五个重要特性：**有穷性、确定性、可行性、输入、输出**。
4. 什么是**时间复杂度**：一个语句的执行次数被称为语句的频度，所有语句的频度之和记为**T(n)**，他是算法问题规模n的函数，时间复杂度主要就研究它的数量级。

$$
T(n)=O(f(n))
$$

算法的时间复杂度不仅取决于问题的规模，而且取决于带输入数据的性质。



### 第二章

1. 顺序表可以**随机存取**，而单链表只能**顺序存取**

2. **头指针**是**指向链表第一个节点**的指针,**头结点是带头结点链表的第一个节点，节点内通常不存储信息。**

3. 引入头结点的两个好处：**首先可以使链表第一个位置上的操作和其他位置一样，无需特殊处理，其次可以是使空表和非空表的处理统一起来**

4. 单链表的**头插和尾插**，头插法关键在于：`s->next=L->next;L->next=s;`

   尾插法关键在于：`LNode *r=L;r->next=s;r=s;`

5. 链表的**删除**操作：`LNode *q=p->next;p->next=q->next;free(q);`

6. 如何快速找到一个**单链表的三分之一处**？

   答：可以使用双指针法，一个指针fast一次走三步，一个指针slow一次走一步，fast指针结束，返回slow指针的位置。

7. 循环单链表的判空条件是它是否等于头指针，循环单链表不设头指针而仅设置尾指针，这样对表头和表尾的操作只需要O(1)的时间复杂度

8. **静态链表**：借助数组来描述线性表的链式存4储结构，这里的指针是指**节点的相对地址(数组下标)**，在操作系统文件管理那里有个文件的**显式链接的FAT文件分配表**那里有应用。

### 第三章

1. 循环队列：

`初始时：Q.front=Q.rear=0;`

`进队：Q.rear=(Q.rear+1)%MaxSize`

`出队：Qfront=(Q.front+1)%MaxSize`

`队列长度：(Q.rear+MaxSize-Q.front)%MaxSize`

`队满条件:(Q.rear+1)%MaxSize==Q.front`

`队空条件：Q.front==Q.rear`

为了区分队空和队满有三种处理方式：

1. 牺牲一个存储单元来区分队空还是队满
2. 增设表示数据元素个数的数据成员
3. 增设tag数据成员，tag为0则队空，tag为1则队满



**双端队列**：允许两端都可以入队和出队的队列



### 第四章

- 树中的节点数等于所有节点的度数之和加一

- **完全二叉树**：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

  特点是：叶子节点只会出现在最后两层；节点编号i若小于等于n/2向下取整，则为分支节点，否则为叶子结点；**若存在度为1的节点，那么这个节点有且只能有一个；且该节点只有左孩子无右孩子**；

- 二叉树的性质：

  - 非空二叉树的叶子结点数等于度为2的节点数加一
  - 非空二叉树第k层上至多有2的k-1次方个节点
  - 高度为h的二叉树至多有2的h次方减一个节点

- 二叉树的遍历，后序遍历的非递归算法中必须使用到栈，层次遍历需要用到队列。

- **线索二叉树**：在n个节点的二叉树中有n+1个空指针，引入线索二叉树就是为了加快查找节点前驱和后继的速度

- **树**：树的三种常用存储结构：

  - 双亲表示法：就是静态链表类似的结构
  - 孩子表示法：拉链法
  - 孩子兄弟表示法：还是二叉树，只不过变成了左孩子右兄弟

- **树、二叉树和森林的转换**

  树转换成二叉树的规则是**左孩子右兄弟**。森林转换成二叉树的规则是先把森林中的每棵树转换成二叉树，再把它们的根视为兄弟关系连接起来。将二叉树转换成森林的规则是把根的右链断开。

- 树的先根遍历和后根遍历对应二叉树的先序遍历和中序遍历

- **WPL**(带权路径长度)：从根出发到任意节点的路径长度与该点权值的乘积，称为该节点的带权路径长度。所有叶节点的带权路径长度之和称为树的WPL，在哈夫曼树中WPL等于所有非叶结点的权值之和

- **哈夫曼树**: 在含有n个带权叶节点的二叉树中，WPL最小的称为哈夫曼树。(哈夫曼树中不存在度为1的节点)

- **哈夫曼编码**：是可变字长编码的一种，利用哈夫曼树可以设计出总长度最短的二进制前缀编码。

- 哈夫曼编码的应用：数据压缩、文件压缩、图像编码处理



### 第五章

- **简单图**：不存在重复边；不存在顶点到自身的边

- **完全图**：对于无向图，边的取值范围是0到**n*(n-1)/2**,对于有向图，边的取值范围是0到**n*(n-1)**

- **连通分量**:无向图的极大连通子图

- **强连通分量**：有向图的极大强连通子图

- **生成树**：包含图中所有顶点的**极小连通子图**

- 无向图的全部顶点的度之和等于边数的两倍；有向图的全部顶点的入度之和和出度之和相等且等于边数

- 若一个图有**n个顶点**，并且有**大于n-1**条边，则此图一定有**环**

- **图的邻接矩阵**：

  - 无向图的邻接矩阵一定是一个对称矩阵，并且唯一。实际存储只需要存储上(下)三角矩阵的元素
  - 对于无向图，邻接矩阵第i行非零元素的个数刚好是该顶点的度
  - 对于有向图，邻接矩阵第i行非零元素的个数刚好是该顶点的出度；邻接矩阵第j列非零元素的个数刚好是该顶点的入度
  - 稠密图适合邻接矩阵，稀疏图适合邻接表

- **图的邻接表**：

  - 在有向图的邻接表表示法中，求给定顶点的出度只需计算邻接表中结点的个数，但求其顶点的入度需要遍历全部的邻接表。
  - 邻接表中存在两种节点，顶点表节点和边表节点

- **广度优先搜索(BFS)**：类似于二叉树的层序遍历,是一种分层查找过程，它不是一个递归算法，为了实现逐层访问，必须借助一个辅助队列，记忆正在访问节点的下一层节点。时间复杂度为O(|V|的平方),空间复杂度为O(|V|),使用BFS可以求非带权图(或者权值一样)的单源最短路径，这是由BFS总是按照距离从近到远遍历图中每个顶点决定的

- **深度优先搜索(DFS)**：类似于二叉树的先序遍历，DFS是一个递归算法，需要借助递归工作栈，时间复杂度为O(|V|+|E|),空间复杂度为O(|V|)

  图的遍历算法可以判断图的连通性

- 无向连通图最多几条边，最少几条?

  答：最多n*(n-1)/2,最少n-1

- **最小生成树**：给定一个带有权值的连通图（连通网），从众多的生成树中筛选出权值总和最小的生成树，即为该图的*最小生成树*

  一般来说最小生成树不唯一，但当带权连通图中任意一个环所包含的边的权值均不相同时，其MST是唯一的。

  最小生成树边的权值之和总是唯一的，其边数为顶点数减一。

- Prim算法和Kruskal算法的区别：

![image-20230224215005180](https://pic.imgdb.cn/item/63f8c1aaf144a01007b2cb8b.png)

- **最短路径**：带权路径长度最短的那条路径称为最短路径。

  广度优先算法求解最短路径针对无权图(或者权值一样)而言，求带权有向图一般两种算法：迪杰斯特拉算法和弗洛伊德算法。

  迪杰斯特拉算法基于贪心策略，求源点到某个特定顶点的最短路径和到其他所有顶点的最短路径一样复杂，时间复杂度都为O(|V|2),当边上带有负权值时，迪杰斯特拉算法并不适用

  弗洛伊德算法时间复杂度为O(|V|3)，允许图中带有负权值的边，但不允许带有负权值边的回路

- **拓扑排序**：使用邻接表存储时拓扑排序的时间复杂度为O(|V|+|E|)，实用邻接矩阵存储时拓扑排序的时间复杂度为O(|V|2),深度优先搜索也可实现拓扑排序，判断图中是否有环



### 第六章

- **折半查找(二分查找)**：仅适用于**有序的顺序表**，查找过程：

  ① 首先确定整个查找区间的中间位置 mid = (left + right)/2 。

  ② 用待查关键字值与中间位置的关键字值进行比较；若相等，则查找成功；若大于，则在后（右）半个区域继续进行折半查找；若小于，则在前（左）半个区域继续进行折半查找。

  ③ 对确定的缩小区域再按折半公式，重复上述步骤。最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存放

  **时间复杂度为O(log2n)**

- **二叉排序树**：二叉排序树本质是一棵二叉树，它的特别之处在于：

  对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小；

  对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大。

  左右子树分别是一棵二叉排序树

  - **删除过程**：
    - 若被删除节点是叶子节点，直接删除，不会破坏二叉排序树的性质
    - 若被删除节点有一个左子树或者右子树，删除后让其子树代替
    - 若被删除节点左右子树均不空，在右子树上找中序序列的第一个子女填补
  - **二叉排序树的查找效率分析**：
    - 查找效率主要取决于树的高度
    - 若输入序列是有序的，就是最坏情况下，其时间复杂度为O(n)
    - 若变成平衡二叉树，查找时间复杂度就是O(log2n)
    - 二叉排序树可作为二分查找的逻辑结构

  

  

  **平衡二叉树**：

  - 插入过程：
    - LL型(单次右旋)
    - RR型(单次左旋)
    -  LR型(先单次左旋，再单次右旋)
    - RL型(先单次右旋，再单次左旋)
  - 删除过程：
    - 叶子节点直接删除
    - 其他节点删除后要回溯到最靠近根节点的失衡节点进行调整，调整方法和插入一样

  

  **红黑树**：

  - 红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)
  
  - 以红黑树为例，红黑树通过如下的性质定义实现自平衡：
    
    > 节点是红色或黑色。
    > 根是黑色。
    > 所有叶子都是黑色（叶子是NIL节点）。
    > 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
    > 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。

  **B树**：

  - 又称多路平衡查找树， **树中所有孩子结点个数的最大值称为该树的阶！树的阶数表示一个节点最多能有多少个子节点，也就是每个节点上最多的键值个数。比如二叉树的阶数就是2**
  - 根节点至少拥有两个子树，除了根节点之外的非叶子节点拥有K个子树以及K-1个元素((M+1/2) < K < M)，元素按照递增或递减顺序排列
  - 所有叶子节点属于同一层

  

**哈希表**：

- 哈希函数的构造方法：直接定址法、除留余数法、数字分析法、平方取中法
- 处理哈希冲突的方法：
  - 开放定址法：线性探测法、平方探测法、双散列法、伪随机序列法
  - 拉链法
- 开放地址法如何删除关键字？（应该不是直接物理删除，做个标记虚拟删除）
- 哈希查找的效率取决于三个因素：散列函数、处理冲突的方法、装填因子
- 哈希查找的时间复杂度为O(1)



### 第七章

- **快速排序**：

  - 快速排序的**最坏运行情况是 O(n²)**，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数**顺序性较弱**的随机数列而言，快速排序总是优于归并排序。

  - 算法步骤：1．先从数列中取出一个数作为基准数。
                        2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
                        3．再对左右区间重复第二步，直到各区间只有一个数

  - 算法代码：

    ```c
    // 分割函数，用于将数组分成两部分，并返回分割的位置
    // 参数：
    // A：待分割数组
    // low：数组起始下标
    // high：数组终止下标
    // 返回值：
    // 返回分割后枢轴元素所在的下标
    int Partition(int A[], int low, int high) {
        int pivot = A[low]; // 选择数组中的第一个元素作为枢轴
        while (low < high) { // 循环直到low==high
            while (low < high && A[high] >= pivot) {
                --high; // 从high开始向左搜索小于pivot的元素
            }
            A[low] = A[high]; // 把小于pivot的元素移动到左边
            while (low < high && A[low] <= pivot) {
                ++low; // 从low开始向右搜索大于pivot的元素
            }
            A[high] = A[low]; // 把大于pivot的元素移动到右边
        }
        A[low] = pivot; // 把枢轴元素放到分割位置
        return low; // 返回分割位置
    }
    
    // 快速排序函数
    // 参数：
    // A：待排序数组
    // low：数组起始下标
    // high：数组终止下标
    void QuickSort(int A[], int low, int high) {
        if (low < high) { // 当数组只有一个元素时，不需要排序
            int pivot = Partition(A, low, high); // 分割数组
            QuickSort(A, low, pivot - 1); // 递归排序分割后的左半部分
            QuickSort(A, pivot + 1, high); // 递归排序分割后的右半部分
        }
    }
    
    ```
  
  - 快速排序时间复杂度，**平均时间复杂度的系数，答案是1.39** 






- #### 乱序的数中想要找到中间大小的值?

  首先将数组的前（n+1）／2个元素建立一个最小堆。

  然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，接着看下一个元素。如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。

  当数组都遍历完了，那么，堆顶的元素即是中位数。

  可以看出，长度为（n＋1）／2的最小堆是解决方案的精华之处。
  
- #### 求最大公约数和最小公倍数

  最大公约数：  辗转相除法：设置死循环(使用递归也可以)：

  1. 取两数中的较大数为m，较小数为n；
  2. 若m%n为0，则n为最大公约数，退出循环；
  3. 将原来的两个数替换为n和m%n，返回步骤1

  只要求出了最大公约数就能求最小公倍数：  `最小公倍数=m*n/最大公约数`

  



- **堆排序**：

  - 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足**堆的性质**：即子节点的键值或索引总是小于（或者大于）它的父节点。
    - 如何调整堆？
      - 被删除元素用堆顶元素替代，然后该元素不断下坠。插入元素不断上浮
      - 构造堆时，对第n除以2向下取整的节点所在子树筛选，调整好后，再调整它前一个节点，一直这样反复调整
      - 输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，再调整堆

  

  

  



#### 一定要会默写基本的排序算法代码以及二分查找的代码

[1.6 快速排序 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/quick-sort-2.html)



**栈的两个应用：括号匹配和表达式的计算是怎么应用的？**

> 1. 括号匹配
>
> 在括号匹配中，可以利用栈的“后进先出”特性，当遇到左括号时，将其压入栈中，当遇到右括号时，弹出栈顶元素进行匹配。如果栈顶元素不是对应的左括号，则表明括号不匹配，返回错误。当所有的括号都匹配完成后，栈应该为空，否则也返回错误。
>
> 2. 表达式计算
>
> 在表达式计算中，可以利用两个栈，一个存放操作数，一个存放操作符。当遇到操作数时，将其压入操作数栈中，当遇到操作符时，比较其与栈顶操作符的优先级，如果当前操作符优先级高于栈顶操作符，则将其压入栈中，否则，弹出栈顶操作符和两个操作数进行计算，将结果压入操作数栈中。当表达式扫描完成后，操作数栈中只剩下一个元素，即为表达式的结果。



#### 16.介绍下字符串模式匹配算法：朴素模式匹配算法和KMP算法

答：串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置

朴素模式匹配算法：将模式串的字符与主串中的每一个子串一一进行比对

KMP算法：指向主串的指针不回溯，依次往后进行比较，而指向模式串的指针需要回溯，当某个位置的字符匹配失败时，模式串指针根据next数组指向相应的位置，再进行匹配。



**如何构造赫夫曼树？**

> 构造哈夫曼树的过程是将一组权值（即字符出现的频率）按照从小到大的顺序排列，然后将权值最小的两个节点合并成一个新的节点，其权值为原来两个节点权值的和，直到所有节点都被合并成一个根节点为止。具体步骤如下：
>
> 1. 将所有的节点按照权值从小到大排序，可以使用堆或者快速排序等算法进行排序。
> 2. 从排序后的列表中取出权值最小的两个节点，合并成一个新的节点，其权值为原来两个节点的权值之和。将这个新的节点插入到列表中。
> 3. 重复步骤2，直到只剩下一个根节点，即构造出了一棵哈夫曼树。



**介绍一下求最短路径的算法？**

> 迪杰斯特拉算法是经典的单源最短路径算法，用于求某一顶点到其他顶点的最短路径，它的特点是以起始点为中心层层向外扩展，直到扩展的终点为止。基本思想为：设置并逐步扩充一个集合S,存放已求出其最短路径的顶点，则尚未确定最短路径的顶点集合是V-S，其中V为网中所有顶点的集合。按最短路径长度递增的顺序将V-S中的顶点逐个加入S中，直到S中包含全部顶点。
>
> Floyd算法，也称为插点法，是一种用于解决任意两点之间的最短路径问题的算法。它的基本思想是动态规划，其核心是构建一个关于顶点之间的距离的矩阵。该算法的主要步骤如下：
>
> 1. 初始化距离矩阵，如果顶点i和顶点j之间有一条边，则矩阵中(i, j)和(j, i)位置的值为这条边的权值；如果没有，则该位置的值为无穷大。
> 2. 对于每个顶点k，计算它与其他顶点之间的距离，如果经过顶点k的路径比直接相连的路径更短，则更新距离矩阵中对应的值。
> 3. 重复步骤2，直到所有顶点都被作为中间点计算过。
>
> 最终，距离矩阵中的值即为任意两点之间的最短距离。该算法的时间复杂度为O(n^3)，其中n为顶点数。





折半查找的代码：

```c
int binarySearch(int a[] , int first, int last, int key) {
	int left = first;
	int right = last;
	while (left <= right) { //这里一定要写<=
		int mid = (left + right)/2;  // mid = left + ((right- left) / 2);
		if (key == a[mid]) 
                      return mid;
		else if (a[mid] < key ) 
                      left = mid + 1;
		else  if( a[mid]  > key) 
                      right = mid - 1;
	}
	return -1; // 未找到key
}
```

这里是最简单的模板， `mid = left + ((right- left) / 2)`写成这样是为了避免整型溢出，当left和right都很大可能加起来就会溢出



#### **二分查找求下界**

```c++
int my_lower_bound(int L, int R, int key) {
	int first = L, last = R;
	while(first <= last) {
		int middle =  (first+last)/2;
		if( a[middle] == key ) 
                    last = middle-1; // first 按兵不动， last移动
                else if(  a[middle] >  key  ) 
                    last = middle-1; 
		else if( a[middle] <  key )
                    first = middle+1; 
	}
	return first;
}
```





#### 归并排序

> ```c
> // 归并排序函数
> void mergeSort(int arr[], int l, int r) {
>     if (l >= r) {
>         // 当l >= r时，终止递归
>         return;
>     }
> 
>     // 计算中间索引
>     int mid = (l + r) / 2;
> 
>     // 分治递归
>     mergeSort(arr, l, mid);
>     mergeSort(arr, mid + 1, r);
> 
>     // 合并有序序列
>     merge(arr, l, mid, r);
> }
> 
> // 合并两个有序序列
> void merge(int arr[], int l, int mid, int r) {
>     int i, j, k;
>     int n1 = mid - l + 1;   // 左半部分数组的大小
>     int n2 = r - mid;       // 右半部分数组的大小
> 
>     // 创建临时数组
>     int L[n1], R[n2];
> 
>     // 将数据复制到临时数组中
>     for (i = 0; i < n1; i++) {
>         L[i] = arr[l + i];
>     }
>     for (j = 0; j < n2; j++) {
>         R[j] = arr[mid + 1 + j];
>     }
> 
>     // 初始化索引
>     i = 0;     // 初始化左半部分数组的索引
>     j = 0;     // 初始化右半部分数组的索引
>     k = l;     // 初始化归并后的数组索引
> 
>     // 归并两个数组
>     while (i < n1 && j < n2) {
>         if (L[i] <= R[j]) {
>             // 如果左半部分数组的值小于右半部分数组的值
>             arr[k] = L[i];
>             i++;
>         } else {
>             // 否则将右半部分数组的值复制到归并后的数组中
>             arr[k] = R[j];
>             j++;
>         }
>         k++;
>     }
> 
>     // 复制左半部分剩余的元素
>     while (i < n1) {
>         arr[k] = L[i];
>         i++;
>         k++;
>     }
> 
>     // 复制右半部分剩余的元素
>     while (j < n2) {
>         arr[k] = R[j];
>         j++;
>         k++;
>     }
> }
> 
> ```
>
> 



> #### 冒泡排序
>
> ```c
> void bubble_sort(int nums[], int n) {
>     for (int i = 0; i < n; i++) {
>         bool swapped = false;
>         for (int j = 0; j < n - i - 1; j++) {
>             if (nums[j] > nums[j + 1]) {
>                 int temp = nums[j];
>                 nums[j] = nums[j + 1];
>                 nums[j + 1] = temp;
>                 swapped = true;
>             }
>         }
>         if (!swapped) {
>             break;
>         }
>     }
> }
> ```
>
> 















