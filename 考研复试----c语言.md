



### 重点问题

- **c和c++的区别**？

  首先c语言是面向过程的语言，而c++是面向对象的语言

  编写c语言程序就是分析解决问题的步骤，之后一步步实现这些步骤，这些步骤写成函数，依次调用即可。而使用c++编写程序的思路是把问题拆分成各个对象，描述对象在解决问题时的行为

  具体语言的区别体现在几个方面：

  - 关键字个数不同，c是37个，c++是63个
  - 返回值不同，c语言默认返回int类型的值，c++若没有返回值类型必须定义为void
  - c语言没有重载函数，c++的函数重载允许声明同名函数但形参的顺序或返回值可以不同

  其代表的面向对象和面向过程的优缺点：

  - 面向过程是：性能高，但是开销大，消耗资源，不易于维护和拓展

  - 面向对象是：性能低，但是易于维护和扩展，编程灵活，可以设计出低耦合的系统

    

- C语言和java的区别和联系

  > 区别：
  >
  > 1. C语言是一种面向过程的编程语言，而Java则是一种面向对象的编程语言。
  > 2. C语言代码需要先编译后运行，而Java则是先编译成字节码，再通过虚拟机解释执行。
  > 3. 在内存管理方面，C语言需要手动进行内存分配和释放，而Java具有自动内存管理机制。
  > 4. C语言中的指针可以直接访问内存地址，而Java中的指针则被隐藏起来，不允许直接操作内存地址。
  > 5. C语言中的变量可以定义在函数内部，而Java中的变量只能定义在类或者方法内部。
  > 6. C语言对于数据类型的转换更加自由，可以进行隐式转换，而Java则需要显式进行类型转换。
  >
  > 联系：
  >
  > 1. C语言和Java都是高级编程语言，可以用于开发各种类型的软件和系统。
  > 2. C语言和Java都支持面向对象的编程方式。
  > 3. C语言和Java都有强大的开发工具和生态系统，如GCC和Eclipse等。
  > 4. C语言和Java都是跨平台的语言，可以在不同的操作系统和硬件平台上运行。
  >
  > 总的来说，C语言和Java都是非常重要的编程语言，各自有着自己的优缺点和适用场景，具体选择哪种编程语言要根据具体的项目需求和开发目标来决定。

- **描述一下gcc编译过程**

  一共有四步：**预处理、编译、汇编、链接**

  - 预处理：**头文件包含、宏替换、条件编译、注释删除**
  - 编译：主要进行语法、词法、语义分析，将**预处理好的文件编译成汇编文件**
  - 汇编：将汇编文件转换成**二进制目标文件**
  - 链接：将二进制文件加上所需的库以及启动代码连接成**可执行文件**

- **什么是预编译**：

  预编译又称预处理，是编译过程中最先做的事，**主要处理#开头的指令**，比如拷贝#include的代码，替换宏定义#define

- **传值、传地址和引用的区别**

  - 传值：会重新分配空间给形参，把实参的值拷贝给形参，形参的修改不会改变实参的值，函数调用结束后，形参就被释放

  - 传地址：在这种传递过程中，形参是指针类型的变量，实参是变量的地址，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参

  - 引用：引用和原变量是同一个东西，只不过是原变量的一个别名。在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。

    **传递引用**给函数与**传递指针**的效果是一样的

- **关键字static的作用？**

  - 用于局部变量的修饰符；当 static 用于修饰局部变量时，通常是在某个函数体内，只能在该函数内被调用。这样定义的变量通常被称为**局部静态变量**，**它的值不会因为函数调用的结束而被清除，当函数再次被调用时，它的值是上一次调用结束后的值。**
  - 用于全局变量的修饰符；静态全局变量的存储位置、初始化操作同静态局部变量的特性，但其作用域有所不同：**静态全局变量可以被该文件内的所有函数访问，但不能被其它文件内的函数访问**。
  - 用于函数的修饰符。**静态函数的作用域仅限于本文件，不能被其它文件调用。**
  
- **结构体和类的区别是什么？**

  - 结构体是存放很多数据的结构，里面不含有对数据的操作，而类里面可以封装对数据的操作
  - 类对成员变量有访问权限，结构体没有，结构体外可以任意访问结构体内的成员，但类外的不能访问定义为private成员
  - 结构体在堆栈中创建是值类型，而类是引用类型

- **break和continue的区别？**

  - break是终止整个循环过程，不再判断循环条件是否成立
  - continue是结束本次循环过程，且continue只能在循环语句中使用，break在Switch语句可以使用

- **C语言运算符的优先级**

  简单记就是：！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符

  | 优先级 | 运算符           | 名称或含义               | 使用形式                 | 结合方向 | 说明       |
  | :----: | ---------------- | ------------------------ | ------------------------ | -------- | ---------- |
  |   1    | []               | 数组下标                 | 数组名[常量表达式]       | 左到右   | --         |
  |   ()   | 圆括号           | (表达式）/函数名(形参表) | --                       |          |            |
  |   .    | 成员选择（对象） | 对象.成员名              | --                       |          |            |
  |   ->   | 成员选择（指针） | 对象指针->成员名         | --                       |          |            |
  |   2    | -                | 负号运算符               | -表达式                  | 右到左   | 单目运算符 |
  |   ~    | 按位取反运算符   | ~表达式                  |                          |          |            |
  |   ++   | 自增运算符       | ++变量名/变量名++        |                          |          |            |
  |   --   | 自减运算符       | --变量名/变量名--        |                          |          |            |
  |   *    | 取值运算符       | *指针变量                |                          |          |            |
  |   &    | 取地址运算符     | &变量名                  |                          |          |            |
  |   !    | 逻辑非运算符     | !表达式                  |                          |          |            |
  | (类型) | 强制类型转换     | (数据类型)表达式         | --                       |          |            |
  | sizeof | 长度运算符       | sizeof(表达式)           | --                       |          |            |
  |   3    | /                | 除                       | 表达式/表达式            | 左到右   | 双目运算符 |
  |   *    | 乘               | 表达式*表达式            |                          |          |            |
  |   %    | 余数（取模）     | 整型表达式%整型表达式    |                          |          |            |
  |   4    | +                | 加                       | 表达式+表达式            | 左到右   | 双目运算符 |
  |   -    | 减               | 表达式-表达式            |                          |          |            |
  |   5    | <<               | 左移                     | 变量<<表达式             | 左到右   | 双目运算符 |
  |   >>   | 右移             | 变量>>表达式             |                          |          |            |
  |   6    | >                | 大于                     | 表达式>表达式            | 左到右   | 双目运算符 |
  |   >=   | 大于等于         | 表达式>=表达式           |                          |          |            |
  |   <    | 小于             | 表达式<表达式            |                          |          |            |
  |   <=   | 小于等于         | 表达式<=表达式           |                          |          |            |
  |   7    | ==               | 等于                     | 表达式==表达式           | 左到右   | 双目运算符 |
  |  ！=   | 不等于           | 表达式!= 表达式          |                          |          |            |
  |   8    | &                | 按位与                   | 表达式&表达式            | 左到右   | 双目运算符 |
  |   9    | ^                | 按位异或                 | 表达式^表达式            | 左到右   | 双目运算符 |
  |   10   | \|               | 按位或                   | 表达式\|表达式           | 左到右   | 双目运算符 |
  |   11   | &&               | 逻辑与                   | 表达式&&表达式           | 左到右   | 双目运算符 |
  |   12   | \|\|             | 逻辑或                   | 表达式\|\|表达式         | 左到右   | 双目运算符 |
  |   13   | ?:               | 条件运算符               | 表达式1?表达式2: 表达式3 | 右到左   | 三目运算符 |
  |   14   | =                | 赋值运算符               | 变量=表达式              | 右到左   | --         |
  |   /=   | 除后赋值         | 变量/=表达式             | --                       |          |            |
  |   *=   | 乘后赋值         | 变量*=表达式             | --                       |          |            |
  |   %=   | 取模后赋值       | 变量%=表达式             | --                       |          |            |
  |   +=   | 加后赋值         | 变量+=表达式             | --                       |          |            |
  |   -=   | 减后赋值         | 变量-=表达式             | --                       |          |            |
  |  <<=   | 左移后赋值       | 变量<<=表达式            | --                       |          |            |
  |  >>=   | 右移后赋值       | 变量>>=表达式            | --                       |          |            |
  |   &=   | 按位与后赋值     | 变量&=表达式             | --                       |          |            |
  |   ^=   | 按位异或后赋值   | 变量^=表达式             | --                       |          |            |
  |  \|=   | 按位或后赋值     | 变量\|=表达式            | --                       |          |            |
  |   15   | ，               | 逗号运算符               | 表达式,表达式,…          | 左到右   | --         |

- **C语言的内存分配**

  在C语言中，定义了4个内存区间：**代码区；全局变量与静态变量区；局部变量区即栈区；动态存储区，即堆区。**下面分别对这4个区进行介绍。
  ① 代码区。代码区中主要存放程序中的代码，属性是只读的。
  ② 全局变量与静态变量区。也称为**静态存储区域**。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如：**全局变量、静态变量和字符串常量**。分配在这个区域中的变量，当程序结束时，才释放内存。因此，经常利用这样的变量，在函数间传递信息。
  ③ 栈区。在栈上创建。在执行函数时，**函数内局部变量的存储单元都可以在栈上创建**，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。在linux系统中，通过命令“ulimit –s”，可以看到，栈的容量为8192kbytes，即8M。
   这种内存方式，变量内存的分配和释放都自动进行，程序员不需要考虑内存管理的问题，很方便使用。但缺点是，栈的容量有限制，且当相应的范围结束时，局部变量就不能在使用。
  ④ 堆区。有些操作对象**只有在程序运行时才能确定**，这样编译器在编译时就无法为他们预先分配空间，只能在程序运行时分配，所以称为**动态分配**。

- **C语言里面main函数有什么参数？分别有什么作用？**

  第一个参数 argc ，用于存放命令行参数的个数。
  第二个参数 argv，是个字符指针的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。
  第三个参数 envp ,也是一个字符指针的数组，这个数组的每一个元素是指向一个环境变量的字符指针。

- **任何类型的指针变量都是占用4个字节**

  指针即为地址，指针几个字节跟语言无关，而是**跟系统的寻址能力有关**，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节

- **函数指针和回调函数**：

  ```c
  #include <stdio.h>
   
  int max(int x, int y)
  {
      return x > y ? x : y;
  }
   
  int main(void)
  {
      /* p 是函数指针 */
      int (* p)(int, int) = & max; // &可以省略
      int a, b, c, d;
   
      printf("请输入三个数字:");
      scanf("%d %d %d", & a, & b, & c);
   
      /* 与直接调用函数等价，d = max(max(a, b), c) */
      d = p(p(a, b), c); 
   
      printf("最大的数字是: %d\n", d);
   
      return 0;
  }
  ```

  函数指针作为某个函数的参数
  函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。



- **typedef和#define的区别**

  - typedef是一种声明自定义数据类型的关键字，在编译阶段有效，故可以进行类型检查
  - #define是预处理指令，发生在编译之前，只进行替换而不做检查

  

  

- #### 关于指针

  1. 指针和数组的区别 

     > 在C语言中，数组和指针有些相似，因为它们都可以用来访问内存中的数据。但是它们有着很大的区别。数组是一组相同类型的数据的集合，而指针是一个变量，存储的是某个内存地址。数组名代表的是数组首元素的地址，可以当做指针来使用。
  
  2. 指针和引用的区别 
  
     > 在C++语言中，引用是一个变量别名，和指针相比，它具有更高的安全性，因为它不允许指向空值或未初始化的变量。而指针是一个变量，存储的是某个内存地址，可以用来直接访问内存中的数据。
  
  3. 野指针和空指针 
  
     > 野指针是指未初始化或已经释放的指针，指向一块随机的内存地址，访问野指针会导致程序崩溃或者出现未知的错误。而空指针是指未初始化的指针，它不指向任何有效的内存地址，使用空指针时需要特别注意，否则会导致程序崩溃。
  
  4. 指针运算 
  
     > 指针可以进行四种运算：加、减、比较、取地址。指针加上一个整数n，实际上是将指针指向的地址加上n乘以指针指向的类型所占用的字节数。指针减去一个整数n，实际上是将指针指向的地址减去n乘以指针指向的类型所占用的字节数。指针比较时，实际上是比较两个指针所指向的地址是否相等。取地址操作符&，可以返回一个变量的地址。
  
  5. 如何在函数之间传递指针？指针作为函数参数有什么优缺点？
  
     > 在C语言中，可以通过将指针作为函数参数来在函数之间传递指针。这种方法允许函数修改指针指向的值或者修改指针本身，从而使得多个函数可以共享同一块内存区域，实现数据的共享。
     >
     > 指针作为函数参数的优点是可以节省内存空间，因为不需要把整个数组或者结构体传递给函数，只需要传递它们的地址即可。此外，使用指针作为函数参数可以使函数更加灵活，可以处理不同大小和类型的数据结构。
     >
     > 然而，指针作为函数参数也存在一些缺点。如果指针被错误地使用或者传递了错误的指针，就有可能导致程序崩溃或者出现严重的错误。此外，使用指针作为函数参数可能会增加代码的复杂性，需要更加小心地编写代码来保证指针被正确使用。
  
  6. 什么是指针常量和常量指针，它们的区别是什么？
  
     > 指针常量是指针本身是常量，指向的内存区域的值可以改变。例如：
     >
     > ```c
     > int a = 10;
     > int b = 20;
     > int * const p = &a;   // p是一个指向int类型的常量指针，指向a
     > *p = 30;              // 可以通过p修改a的值
     > p = &b;               // 错误，p是一个常量，不允许改变它指向的内存区域
     > ```
     >
     > 常量指针是指指向的内存区域的值是常量，指针本身的值可以改变。例如：
     >
     > ```c
     > int a = 10;
     > int b = 20;
     > const int *p = &a;    // p是一个指向常量int类型的指针，指向a
     > //*p = 30;            // 错误，不能通过p修改a的值
     > p = &b;               // 可以修改p指向的位置，指向b
     > ```
     >
     > 因此，**指针常量和常量指针的区别在于指针本身是常量还是指向的内存区域是常量**。在实际编程中，可以根据需要来选择使用哪种类型的指针。
  
  7. 什么是指针的指针，如何使用它们？
  
     > 指针的指针也称为二级指针，是指一个指针变量存储的是另一个指针变量的地址。换句话说，它是指向指针的指针。
     >
     > 使用二级指针可以方便地传递指针的指针，例如在函数中动态分配内存时，可以使用二级指针将分配的内存地址传递回调用函数。另外，二级指针也可以用于实现多级链表、多维数组等数据结构。
     
  8. C语言中有哪些常用的文件操作函数？请分别说明它们的功能和用法。 
  
     > 1. 常用的文件操作函数有：
     >
     > - fopen(): 打开文件，返回文件指针
     > - fclose(): 关闭文件
     > - fgetc(): 读取一个字符
     > - fgets(): 读取一行字符串
     > - fputc(): 写入一个字符
     > - fputs(): 写入一行字符串
     > - fread(): 读取二进制数据
     > - fwrite(): 写入二进制数据
     > - fseek(): 移动文件指针
     > - ftell(): 获取当前文件指针位置
     > - remove(): 删除文件
     > - rename(): 重命名文件
  
  9. 如何打开一个文件？请说明在打开文件时所使用的模式及其含义。 
  
     > 1. 打开文件使用fopen()函数，语法为：FILE *fopen(const char *filename, const char *mode); 其中filename为文件名，mode为打开模式，常用模式有：
     >
     > - "r": 只读模式，文件必须存在
     > - "w": 只写模式，如果文件存在则清空，不存在则创建
     > - "a": 追加模式，写入数据会添加到文件末尾，不存在则创建
     > - "r+": 读写模式，文件必须存在
     > - "w+": 读写模式，如果文件存在则清空，不存在则创建
     > - "a+": 读写模式，写入数据会添加到文件末尾，不存在则创建
  
  10. 如何在文件中读取和写入数据？请说明C语言中文件读写函数的用法和注意事项。 
  
      > 1. 文件读写使用fread()和fwrite()函数读写二进制数据，使用fgetc()、fgets()、fputc()和fputs()函数读写文本数据。注意事项有：
      >
      > - 在读写文本文件时，需要注意文件编码格式，避免读取乱码
      > - 在读写二进制文件时，需要注意字节序和数据类型
  
  11. 请举例说明如何使用C语言读取一个文本文件，并在控制台中显示出来。 
  
      > ```c
      > #include <stdio.h>
      > 
      > int main() {
      >     FILE *fp;
      >     char filename[] = "test.txt";
      >     char line[100];
      > 
      >     fp = fopen(filename, "r");
      >     if (fp == NULL) {
      >         printf("Failed to open file %s\n", filename);
      >         return -1;
      >     }
      > 
      >     while (fgets(line, sizeof(line), fp) != NULL) {
      >         printf("%s", line);
      >     }
      > 
      >     fclose(fp);
      > 
      >     return 0;
      > }
      > ```
  
  12. 如何在C语言中创建、删除和重命名文件？请说明相关函数的使用方法。 
  
      
  
      >1. 创建文件使用fopen()函数，删除文件使用remove()函数，重命名文件使用rename()函数。相关函数使用方法：
      >
      >- 创建文件：FILE *fopen(const char *filename, const char *mode);
      >- 删除文件：int remove(const char *filename);
      >- 重命名文件：int rename(const char *oldfilename, const char *newfilename);
  
  13. 说明在C语言中对文件进行读写操作时可能会出现哪些错误，以及如何处理这些错误。
  
      > 1. 文件操作可能会出现以下错误：
      >
      > - 文件不存在
      > - 文件权限不足
      > - 磁盘空间不足
      > - 文件被其他程序占用 处理这些错误需要根据具体情况进行相应的处理，如给出错误提示、关闭文件、删除文件等。
  
  
  
  
