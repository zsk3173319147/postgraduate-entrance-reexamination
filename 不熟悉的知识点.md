#### 什么是黑盒测试和白盒测试？

> 黑盒测试和白盒测试是软件测试的两种基本方法。它们的区别在于测试者是否需要知道软件内部的具体实现。
>
> 黑盒测试指的是不考虑被测试软件的内部实现，仅仅从用户或者系统外部的角度出发进行测试，测试者只关心软件是否符合预期的功能和性能要求。黑盒测试通常通过输入一些测试用例，验证软件的输出是否符合预期来进行测试。黑盒测试可以帮助测试者了解被测试软件的功能和性能是否符合要求，但是对于软件内部的实现和设计并不关注。
>
> 白盒测试则相反，测试者需要了解被测试软件的内部实现和代码结构，根据这些信息设计测试用例并进行测试。白盒测试主要针对软件的代码结构和内部逻辑进行测试，以保证软件在实现上的正确性。白盒测试通常包括代码覆盖率测试、路径测试、边界测试等等。
>
> 总之，黑盒测试和白盒测试各有优缺点，通常需要结合使用。黑盒测试主要用于测试软件的功能和性能，白盒测试主要用于测试软件的实现和代码结构。



#### 详细说说操作系统的管理功能

> - 处理机管理：进程控制、进程同步、进程通信、进程调度
> - 存储管理：内存分配、内存保护、内存扩充、地址映射
> - 设备管理：缓冲管理、设备分配、设备处理程序
> - 文件管理：文件存储空间的管理、目录管理、文件的读写管理和保护



#### 进程和线程的区别？

> 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。
>
> 根本区别：**进程**是操作系统**资源分配**的基本单位，而**线程**是处理器**任务调度**和执行的基本单位
>
> 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
>
> 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
>
> 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
>
> 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
>
> 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行



#### 为什么要进行处理机调度？

> 进行处理机调度的主要目的是提高计算机系统的资源利用率和性能。在一个多道程序系统中，存在多个进程或作业等待处理机的分配。如果没有进行处理机调度，那么处理机的利用率就会很低，很多进程或作业就会长时间处于等待状态，从而导致系统的响应时间变长，用户体验变差，同时也会浪费计算机系统的资源。
>
> 通过进行处理机调度，可以合理地分配处理机资源，使得进程或作业能够尽快得到处理，系统的吞吐量和响应时间都可以得到改善，同时也能够避免一些资源竞争和冲突问题，提高计算机系统的稳定性和可靠性。



#### 什么是临界资源？

> 在计算机系统中，临界资源是指同时只能被一个进程或线程访问的共享资源，例如打印机、磁盘等硬件资源，以及共享内存、全局变量等软件资源。
>
> 由于临界资源是共享的，因此在多个进程或线程同时访问时会存在互斥和竞争的问题。如果不加以控制，可能会导致数据不一致、死锁、饥饿等问题。因此，在访问临界资源时需要采取同步机制，例如使用信号量、互斥量等方式进行进程或线程的互斥访问，避免资源的竞争和冲突，确保计算机系统的正确性和稳定性。





#### 进程同步的条件

> 1. 空闲让进：当临界资源空闲时，请求进程立即获得访问权。
> 2. 忙则等待：当临界资源被占用时，请求进程进入等待状态，直到占用资源的进程释放资源。
> 3. 有限等待：进程在等待一定的时间内仍未获得资源，则放弃该资源请求，避免进程饥饿。
> 4. 让权等待：当一个进程请求临界资源被占用时，该进程可以选择放弃处理机，进入等待状态，让出处理机给其他进程使用，从而避免进程饥饿。



#### 我的程序只写了几行，但是最终却有几百kb，这是为什么？

> 1. 引入了大量的库文件，这些库文件会被链接到最终的程序中，增加了程序的大小。
> 2. 编译器可能会为了优化代码，增加了一些冗余的代码，比如一些空函数、调试信息等。
> 3. 程序中包含了大量的静态数据，比如预先定义好的大数组、字符串等，这些数据也会被包含在最终的程序中。
> 4. 程序中包含了大量的注释，注释也会被编译器处理，包含在最终的程序中。
> 5. 编译器可能会为了符合规范，生成一些符号表、调试信息等，这些信息也会被包含在最终的程序中。
> 6. 还有可能是一些操作系统终止的代码



#### 中断相关

> 当中断事件发生时，处理器会暂停当前执行的任务，保存当前任务的上下文（如程序计数器、寄存器等状态信息），然后转而执行中断处理程序。中断处理程序会对中断事件进行处理，并可能执行一些额外的操作，最后再恢复上下文，让被中断的任务继续执行。
>
> 中断的流程：
>
> **关中断、**
>
> **保存断点、**
>
> **引入中断服务程序（前三步由中断隐指令完成）、**
>
> **保存现场和屏蔽字、**
>
> **开中断、**
>
> **执行中断服务程序、**
>
> **关中断、**
>
> **恢复现场和屏蔽字、**
>
> **开中断**
>
> **返回断点。**

### DMA流程

> CPU发送DMA请求到DMA控制器。
> DMA控制器接收到请求后，向总线控制器发出总线请求。
> 总线控制器响应DMA控制器的请求，将总线控制权交给DMA控制器。
> DMA控制器从存储器中读取数据，并将其存储到设备的缓冲区中。
> DMA控制器传输完数据后，将总线控制权交还给CPU。



#### 周期窃取

> I/O设备要求DMA传送会遇到三种情况，一种是此时CPU不需访问主存(如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需访问主存)，故I/O设备访存与CPU不发生冲突。
>
> 第二种情况是I/O设备要求DMA传送时，CPU正在访存，此时必须待存取周期结束时刻，CPU才能将总线占有权让出。
>
> 第三种情况是I/O设备要求访存时，CPU也要求访存，这就出现了访存冲突。此刻，I/O访存优先于CPU访存，因为I/O不立即访存就可能丢失数据，这时I/O要窃取一二个存取周期，意味着CPU在执行访存指令过程中插入了DMA请求，并挪用了一二个存取周期，使CPU延缓了一二个存取周期再访存



#### cache原理

> 局部性原理
>
> cache找不到去主存找，并把相应的数据块调入cache，如果cache满了，还需要根据某种替换算法将其换出主存



#### 拓扑排序的原理及特点

> 拓扑排序是一种有向无环图（DAG）的排序算法，将DAG中的所有顶点排序成线性序列。如果DAG中存在环，拓扑排序算法将无法得出结果。
>
> 拓扑排序的实现过程如下：
>
> 1. 从DAG图中选择一个没有前驱（即入度为0）的顶点，并输出该顶点。
> 2. 从图中删除该顶点以及所有以它为起点的有向边。
> 3. 重复步骤1和2，直到图为空或者图中不存在无前驱的顶点为止。
>
> 如果最终输出的顶点数小于图中的顶点数，说明图中存在环，拓扑排序无法完成。
>
> 拓扑排序可以用于判断有向图中是否存在环，以及任务的依赖关系排序等场景。
>
> 1. 只适用于有向无环图：拓扑排序算法只适用于有向无环图(DAG)，因为DAG的节点之间是有方向的，不存在环路，可以进行拓扑排序，而对于存在环路的有向图，拓扑排序算法不适用。
> 2. 输出所有节点：拓扑排序算法会输出DAG的所有节点，而且输出的顺序是满足拓扑排序规则的。
> 3. 拓扑序不唯一：一个DAG可以有多个拓扑序，也就是说，一个DAG的节点可以有多个排序结果。
> 4. 应用广泛：拓扑排序算法在计算机科学中有着广泛的应用，比如任务调度、依赖关系的分析等领域都会用到拓扑排序算法。
> 5. 时间复杂度较高：拓扑排序算法的时间复杂度为O(V+E)，其中V表示节点数，E表示边数。在稠密图中，边数E和节点数V的乘积接近于V^2，所以拓扑排序算法的时间复杂度较高。



#### 网站点击的过程会发生什么？

> 1) 浏览器分析链接指向页面的URL（http://www.tsinghua.edu.cn/chn/index.html）
>
> 2) 浏览器向DNS请求解析[www.tsinghua.edu.cn的IP](http://www.tsinghua.edu.cn的IP)地址，DNS解析出IP地址。
>
> 3) 浏览器与Web服务器建立TCP连接。
>
> 4) 浏览器向Web服务器发送相应的HTTP或HTTPS请求：GET/chn/index/html
>
> 5) Web服务器通过HTTP响应把文件index.html发送给浏览器
>
> 6. TCP连接释放
>
> 7) 浏览器解析HTML文件，并将Web页显示给用户



#### 交叉连接: 

> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配
>
> 在数据库中，交叉连接（Cross Join），也称为笛卡尔积（Cartesian Product），是一种用于将两个或多个表的每一行与其他表中的每一行匹配的操作。交叉连接会生成一个新表，其中包含两个或多个表中的所有行的组合。这个新表的行数等于连接的表的行数的乘积。
>
> 例如，如果表A有3行，表B有4行，那么它们的交叉连接将生成一个新表，其中包含12行。每一行都由表A和表B中的每一行组成。如果交叉连接中有多个表，则新表中的每一行都由所有表中的每一行组成。



#### varchar和char的使用场景?

> 在数据库中，`char`和`varchar`都是用来存储字符数据类型的，它们的主要区别在于存储方式和使用场景。
>
> `char`类型是定长字符串类型，需要预先指定长度。它存储的字符数始终是指定长度，如果实际存储的字符数少于指定长度，则会在其后补齐空格字符。由于是定长存储，所以char在查询时的性能相对较高，适合用于存储长度固定的数据，例如邮政编码、电话号码等。
>
> `varchar`类型是变长字符串类型，不需要预先指定长度，它只会存储实际存储的字符数，并且不会在其后补齐空格字符。由于是变长存储，所以varchar在查询时的性能相对较低，但是对于长度不固定的数据，例如文章内容、个人简介等，使用varchar会更加方便。
>
> 因此，一般来说，如果存储的数据长度是固定的，比如省份、国家等，就使用char类型；如果存储的数据长度是不固定的，比如姓名、地址等，就使用varchar类型。
>
> char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。
>
> 两者的存储数据都非unicode的字符数据。



#### 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?

> 悲观锁（Pessimistic Lock）:
> 悲观锁特点:先获取锁，再进行业务操作。
> 即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。
> 补充：
> 不同的数据库对select for update的实现和支持都是有所区别的，
> oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。
> MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。
> 乐观锁（Optimistic Lock）:
>
> 1. 乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。
>    2. 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。
>       乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。
>       3. 一般的做法是在需要锁的数据上增加一个版本号，或者时间戳



#### **一只小白鼠喝了毒药后一小时就会离世，现在给你十只小白鼠，一千瓶液体，其中999瓶是水，只有一瓶毒药，如何在一个小时内找出这瓶毒药呢？**

> [智力题------小白鼠试毒问题_小白鼠问题_罗古洞的女婿的博客-CSDN博客](https://blog.csdn.net/chk_plusplus/article/details/118001354)  真的NB
>
> 类似的智力题还有 盛水、之后还有那个天平称重分成三组
>
> 1. 有三个袋子，分别装有红色球、绿色球和红绿混合球。每个袋子标签都是错误的，也就是说，红球袋子可能被标记为绿球袋子等等。你可以从一个袋子中随机选择一个球，但不能看到里面的颜色。你选择一个袋子并从中选择一个球，发现是红色的。请问，该怎么做才能最大限度地找到其他两个袋子的颜色，需要选择哪个袋子？
> 2. 你有两个鸡蛋，可以从 100 层的大楼上扔下去，如果鸡蛋摔碎了，那么就不能再使用。如果鸡蛋没有摔碎，你可以将其捡起并继续使用。如果一个鸡蛋在某个楼层扔下来就碎了，你需要知道那个临界楼层是哪一层。现在给你两个鸡蛋，请问你需要采取什么策略才能保证在最坏的情况下（无论临界楼层在哪一层），最少需要扔多少次鸡蛋才能知道临界楼层是哪一层？
> 3. 你有一堆石头，每块石头上都有一个数字。你需要将这些石头分成两堆，使得两堆石头的数字之和的差最小。请问，最小的差值是多少？



#### 请说出const与#define 相比，有何优点？

> const与#define都可以用于定义常量，但是它们的实现方式和使用场景不同，const比#define有以下优点：
>
> 1.类型检查：使用const定义常量时，编译器会对其进行类型检查，如果赋值类型不符合声明类型会发出警告或错误提示，从而避免了一些错误。
>
> 2.作用域：使用const定义常量时，它的作用域是有限的，只在定义的块中有效，而使用#define定义的常量则是全局的，可能会造成命名冲突和意外修改的问题。
>
> 3.表达力：使用const定义常量可以提供更好的表达力，可以为常量命名，并添加注释和类型说明，从而增加了代码的可读性和可维护性。
>
> 4.代码安全：使用const定义常量可以避免一些宏定义带来的潜在问题，如宏名被意外覆盖、宏定义的优先级问题、宏定义导致的代码阅读困难等问题。
>
> 5.编译器优化：const定义的常量可以被编译器优化，如常量折叠和常量传播，可以提高代码的执行效率。
>
> 总之，使用const定义常量比使用#define更加安全、可读性更强，更加易于维护。



#### 数组和指针的区别

> 数组要么在静态存储区被创建(如全局数组)，要么在栈上被创建。指针可以随时指向任意类型的内存块。
>
> 数组和指针都是 C/C++ 中的重要概念，它们在语法和实现上有着一些不同。
>
> 1. 定义方式不同：
>
> 数组的定义方式是在变量名后面加上方括号，并在方括号中指定数组的大小，例如：`int arr[10];`。在定义数组的同时就确定了其大小，数组大小不能改变。
>
> 指针的定义方式是在变量名前面加上星号符号，例如：`int *ptr;`。指针并没有固定大小，它是用来存储变量地址的变量。
>
> 1. 内存空间不同：
>
> 数组在内存中是连续的一块空间，每个元素都有自己的地址，可以使用下标进行访问。
>
> 指针在内存中只占据一个地址空间，它存储的是另一个变量的地址，可以通过指针访问另一个变量。
>
> 1. 取地址符号的作用不同：
>
> 数组名取地址时，返回的是整个数组的首地址。
>
> 指针变量取地址时，返回的是它自己的地址。
>
> 1. 使用方式不同：
>
> 对数组变量名使用下标访问数组元素，例如：`arr[0] = 10;`。
>
> 对指针变量使用间接寻址符号（星号符号）访问所指向的内存，例如：`*ptr = 10;`。
>
> 1. 作为函数参数时的表现不同：
>
> 将数组作为函数参数时，实际上传递的是数组的首地址，因此在函数内部可以直接访问数组元素。
>
> 将指针作为函数参数时，实际上传递的是指针所指向的内存地址，因此在函数内部需要使用间接寻址符号（星号符号）才能访问所指向的内存。
>
> 总的来说，数组和指针在内存中的存储方式和使用方式都有所不同，每种方式都有其适用的场景。数组通常用于存储一组有序的数据，而指针通常用于实现动态内存分配和访问动态数据结构，如链表和树等。





#### linux命令

> - ll命令 – 显示指定文件的详细属性信息
> - mv命令 – 移动或改名文件
> - rm命令 – 删除文件或目录
> - vim的一些命令



#### 数据库完整性约束

> 实体完整性、参照完整性、用户定义的完整性。前两个系统必须满足，自动支持。
>
> 常见的完整性约束包括实体完整性（对关系中记录唯一性的约束，即主键的约束）、参照完整性（对关系数据库中建立关联关系的数据表间数据参照引用的约束，即对外键的约束 外键或取空值或取与之关联的主键的值）和用户定义完整性（针对某一具体关系数据库的约束条件）



#### 函数指针了解吗？函数指针指向哪里？

函数指针就是指向函数的指针变量，可以用来调用某个函数，多用于向某个函数传入回调函数这样的场景。
函数指针实际指向的是函数的入口地址。
示例：
char *fun(char* p){
}
char * (*pf)(char *p) = fun; //指向fun的函数指针pf
pf(p); //通过pf调用以p为实参fun函数

#### 那什么是回调函数呢？

> 函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2 执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3 就是回调函数。到此应该明白回调函数的定义了吧？



#### 怎么把C语言里面的字符串转换成整数？

> ```c
> #include <stdio.h>
> #include <string.h>
> 
> int string_to_int(char *str) {
>     int result = 0;
>     int len = strlen(str);
>     for (int i = len - 1; i >= 0; i--) {
>         int digit = str[i] - '0';
>         result += digit * pow(10, len - i - 1);
>     }
>     return result;
> }
> 
> int main() {
>     char *str = "123";
>     int num = string_to_int(str);
>     printf("%d\n", num);
>     return 0;
> }
> ```
>
> 



#### 引用和指针有什么区别？

> 在C++语言中，引用是一个变量别名，和指针相比，它具有更高的安全性，因为它不允许指向空值或未初始化的变量。而指针是一个变量，存储的是某个内存地址，可以用来直接访问内存中的数据。
>
> 引用是给变量起别名，指针则是内存的地址，引用在创建的时候初始化，初始化后就不能指向其他对象了，指针则不必初始化；引用的创建和销毁不会调用类的拷贝构造和析构函数。
>  实际实现的时候,引用的汇编源码就是一个指针常量
>  如 int &a = b在汇编层面相当于  int *const p = &b;
>  而这是再改变a的值 a = 2 相当于 *p = 2



#### 网络地址转换NAT

> NAT是指通过将专用网络地址转换为公有地址，从而对外隐藏内部管理的IP地址。它使得整个专用网只需要一个全球IP地址就可以与因特网连通。NAT路由器将私有地址转换为公有地址，或将公有地址转换成私有地址。网络地址转换（NAT）是一种地址转换技术，它可以将IP数据报文头中的IP地址转换为另一个IP地址，并通过转换端口号达到地址重用的目的1。NAT作为一种缓解IPv4公网地址枯竭的过渡技术，由于实现简单，得到了广泛应用



#### 字典序快排

> 字典序快排是一种基于快速排序算法的字符串排序算法，它将字符串看作是由多个字符组成的序列，按照字符的 ASCII 码值大小进行比较，通过不断地递归划分子问题、对子问题排序和合并解决问题。
>
> 字典序快排的基本思路是：选取一个基准元素，将所有小于基准元素的字符串放在左边，所有大于等于基准元素的字符串放在右边，然后递归地对左右两边的字符串进行排序，最后将排序好的子串合并起来。
>
> 字典序快排的时间复杂度为 O(nlogn)，其中 n 表示字符串的长度。相比其他字符串排序算法，字典序快排具有时间复杂度低、实现简单等优点。
>
> **用快排排一串有字母的字符数组**
>
> > ```c
> > #include <stdio.h>
> > #include <stdlib.h>
> > #include <string.h>
> > 
> > void swap(char **str1, char **str2) {
> >     char *temp = *str1;
> >     *str1 = *str2;
> >     *str2 = temp;
> > }
> > 
> > int partition(char **arr, int low, int high) {
> >     char *pivot = arr[high];
> >     int i = low - 1;
> >     for (int j = low; j < high; j++) {
> >         if (strcmp(arr[j], pivot) < 0) {
> >             i++;
> >             swap(&arr[i], &arr[j]);
> >         }
> >     }
> >     swap(&arr[i+1], &arr[high]);
> >     return i+1;
> > }
> > 
> > void quickSort(char **arr, int low, int high) {
> >     if (low < high) {
> >         int p = partition(arr, low, high);
> >         quickSort(arr, low, p-1);
> >         quickSort(arr, p+1, high);
> >     }
> > }
> > ```



#### 套接字类型

> 套接字（Socket）是一种通信机制，用于实现网络中不同主机之间的进程间通信。套接字在应用层提供了一种抽象的网络编程接口，为应用程序提供了一组函数，可以通过这些函数完成网络数据的发送、接收和控制等操作。根据传输层协议的不同，套接字可以分为以下几种类型：
>
> 1. 流套接字（SOCK_STREAM）：基于TCP协议的一种套接字类型，提供面向连接的可靠数据传输服务。流套接字以字节流的形式进行数据传输，具有数据可靠传输、保序传输和流量控制等特点。常用于需要高可靠性和保密性的应用场景，如Web、邮件和文件传输等。
> 2. 数据报套接字（SOCK_DGRAM）：基于UDP协议的一种套接字类型，提供无连接的不可靠数据传输服务。数据报套接字以数据块的形式进行数据传输，没有数据传输的保证，也不保证数据的顺序。常用于需要高性能和实时性的应用场景，如视频会议和在线游戏等。
> 3. 原始套接字（SOCK_RAW）：一种对网络协议的直接访问方式，提供对IP协议或其他网络层协议的访问。原始套接字可以直接构造和解析网络层协议的数据包，用于实现一些网络安全和网络监控功能。
> 4. 信号套接字（SOCK_SEQPACKET）：一种基于SEQPACKET协议的套接字类型，提供可靠的数据传输服务，保证数据的顺序和传输的可靠性。信号套接字通常用于进程间通信，也可以用于网络数据传输。
>
> 此外，还有一些特殊的套接字类型，如多播套接字（SOCK_MULTICAST）、组播套接字（SOCK_GROUP）等。这些套接字类型用于实现多点通信和组播功能，常用于视频直播、音频广播等应用场景。

#### DMA控制器需要初始化什么内容

①将数据传输缓冲区的起始地址或者结束地址送到地址寄存器中;
②将传输的字节数或字数送到计数器中。
③通过模式寄存器设置工作方式等。





#### 描述迪杰斯特拉算法的过程

> 1. 初始化：设置起点的距离为0，其余点的距离为无穷大。
> 2. 选取当前距离最小的未访问过的节点。
> 3. 遍历该节点的所有出边，如果经过该节点到达其他节点的距离比当前已知的距离更短，则更新该节点的距离。
> 4. 标记该节点为已访问。
> 5. 重复步骤2到4，直到所有节点都被访问过，或者目标节点的距离已经确定。
> 6. 得到起点到目标节点的最短路径。



#### 数字电路和模拟电路的区别？

> - 一类物理量的变化在时间和数量上都是离散的，这一物理量称为数字量，表示数字量的信号称为数字信号，工作在数字信号下的电路称为数字电路
> - 一类物理量的变化在时间和数量上都是连续的的，这一物理量称为模拟量，表示模拟量的信号称为模拟信号，工作在模拟信号下的电路称为模拟电路
> - 1.在一个周期内模拟电路的电流和电压是持续不变的，而数字电路中它的电流和电压是脉动变化的。
> - 2.模拟电路和数字电路两者虽然同样是信号变化的载体，但模拟电路对信号的放大和削减是通过元器件的放大特性（如三极管）来实现操作的，而数字电路是对信号的传输是通过开关特性（如三极管）来实现操作的。
> - 模拟电路可以在大电流高电压下工作，而数字电路只是在小电压、小电流、低功耗下工作，完成或产生稳定的控制信号。



#### 什么是僵尸进程？什么是孤儿进程？

> 僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
>
> 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作
>
> 如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。
>
> 当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。
>
> 怎么解决僵尸进程：
>
> 通过信号机制、kill 父进程

#### 什么是上下文切换？

> 上下文切换是指计算机操作系统在多任务环境下，将 CPU 的控制权从一个任务切换到另一个任务的过程。在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器。CPU 寄存器和程序计数器就是 CPU 上下文



#### 事务的故障恢复有哪些？

> 1. 登记日志文件：日志文件是用来记录事务对数据库的更新操作的文件，设立日志文件可以进行事务故障恢复、系统故障恢复、协助后备副本进行介质故障恢复。
> 2. 数据转储：数据转储是指将内存中的数据写入到磁盘中，以便在系统发生故障时能够从磁盘中恢复数据。这种方法通常用于介质故障恢复。
> 3. Undo Log：Undo Log 是一种用于记录事务修改前的数据状态的日志。在发生事务故障时，可以通过回滚 Undo Log 来撤销已经执行的修改操作，从而保证数据一致性。





