#### 什么是黑盒测试和白盒测试？

> 黑盒测试和白盒测试是软件测试的两种基本方法。它们的区别在于测试者是否需要知道软件内部的具体实现。
>
> 黑盒测试指的是不考虑被测试软件的内部实现，仅仅从用户或者系统外部的角度出发进行测试，测试者只关心软件是否符合预期的功能和性能要求。黑盒测试通常通过输入一些测试用例，验证软件的输出是否符合预期来进行测试。黑盒测试可以帮助测试者了解被测试软件的功能和性能是否符合要求，但是对于软件内部的实现和设计并不关注。
>
> 白盒测试则相反，测试者需要了解被测试软件的内部实现和代码结构，根据这些信息设计测试用例并进行测试。白盒测试主要针对软件的代码结构和内部逻辑进行测试，以保证软件在实现上的正确性。白盒测试通常包括代码覆盖率测试、路径测试、边界测试等等。
>
> 总之，黑盒测试和白盒测试各有优缺点，通常需要结合使用。黑盒测试主要用于测试软件的功能和性能，白盒测试主要用于测试软件的实现和代码结构。



#### 详细说说操作系统的管理功能

> - 处理机管理：进程控制、进程同步、进程通信、进程调度
> - 存储管理：内存分配、内存保护、内存扩充、地址映射
> - 设备管理：缓冲管理、设备分配、设备处理程序
> - 文件管理：文件存储空间的管理、目录管理、文件的读写管理和保护



#### 进程和线程的区别？

> 线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。
>
> 根本区别：**进程**是操作系统**资源分配**的基本单位，而**线程**是处理器**任务调度**和执行的基本单位
>
> 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
>
> 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
>
> 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
>
> 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
>
> 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行



#### 为什么要进行处理机调度？

> 进行处理机调度的主要目的是提高计算机系统的资源利用率和性能。在一个多道程序系统中，存在多个进程或作业等待处理机的分配。如果没有进行处理机调度，那么处理机的利用率就会很低，很多进程或作业就会长时间处于等待状态，从而导致系统的响应时间变长，用户体验变差，同时也会浪费计算机系统的资源。
>
> 通过进行处理机调度，可以合理地分配处理机资源，使得进程或作业能够尽快得到处理，系统的吞吐量和响应时间都可以得到改善，同时也能够避免一些资源竞争和冲突问题，提高计算机系统的稳定性和可靠性。



#### 什么是临界资源？

> 在计算机系统中，临界资源是指同时只能被一个进程或线程访问的共享资源，例如打印机、磁盘等硬件资源，以及共享内存、全局变量等软件资源。
>
> 由于临界资源是共享的，因此在多个进程或线程同时访问时会存在互斥和竞争的问题。如果不加以控制，可能会导致数据不一致、死锁、饥饿等问题。因此，在访问临界资源时需要采取同步机制，例如使用信号量、互斥量等方式进行进程或线程的互斥访问，避免资源的竞争和冲突，确保计算机系统的正确性和稳定性。





#### 进程同步的条件

> 1. 空闲让进：当临界资源空闲时，请求进程立即获得访问权。
> 2. 忙则等待：当临界资源被占用时，请求进程进入等待状态，直到占用资源的进程释放资源。
> 3. 有限等待：进程在等待一定的时间内仍未获得资源，则放弃该资源请求，避免进程饥饿。
> 4. 让权等待：当一个进程请求临界资源被占用时，该进程可以选择放弃处理机，进入等待状态，让出处理机给其他进程使用，从而避免进程饥饿。



#### 我的程序只写了几行，但是最终却有几百kb，这是为什么？

> 1. 引入了大量的库文件，这些库文件会被链接到最终的程序中，增加了程序的大小。
> 2. 编译器可能会为了优化代码，增加了一些冗余的代码，比如一些空函数、调试信息等。
> 3. 程序中包含了大量的静态数据，比如预先定义好的大数组、字符串等，这些数据也会被包含在最终的程序中。
> 4. 程序中包含了大量的注释，注释也会被编译器处理，包含在最终的程序中。
> 5. 编译器可能会为了符合规范，生成一些符号表、调试信息等，这些信息也会被包含在最终的程序中。
> 6. 还有可能是一些操作系统终止的代码



#### 中断相关

> 当中断事件发生时，处理器会暂停当前执行的任务，保存当前任务的上下文（如程序计数器、寄存器等状态信息），然后转而执行中断处理程序。中断处理程序会对中断事件进行处理，并可能执行一些额外的操作，最后再恢复上下文，让被中断的任务继续执行。
>
> 中断的流程：
>
> **关中断、**
>
> **保存断点、**
>
> **引入中断服务程序（前三步由中断隐指令完成）、**
>
> **保存现场和屏蔽字、**
>
> **开中断、**
>
> **执行中断服务程序、**
>
> **关中断、**
>
> **恢复现场和屏蔽字、**
>
> **开中断**
>
> **返回断点。**

### DMA流程

> CPU发送DMA请求到DMA控制器。
> DMA控制器接收到请求后，向总线控制器发出总线请求。
> 总线控制器响应DMA控制器的请求，将总线控制权交给DMA控制器。
> DMA控制器从存储器中读取数据，并将其存储到设备的缓冲区中。
> DMA控制器传输完数据后，将总线控制权交还给CPU。



#### 周期窃取

> I/O设备要求DMA传送会遇到三种情况，一种是此时CPU不需访问主存(如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需访问主存)，故I/O设备访存与CPU不发生冲突。
>
> 第二种情况是I/O设备要求DMA传送时，CPU正在访存，此时必须待存取周期结束时刻，CPU才能将总线占有权让出。
>
> 第三种情况是I/O设备要求访存时，CPU也要求访存，这就出现了访存冲突。此刻，I/O访存优先于CPU访存，因为I/O不立即访存就可能丢失数据，这时I/O要窃取一二个存取周期，意味着CPU在执行访存指令过程中插入了DMA请求，并挪用了一二个存取周期，使CPU延缓了一二个存取周期再访存



#### cache原理

> 局部性原理
>
> cache找不到去主存找，并把相应的数据块调入cache，如果cache满了，还需要根据某种替换算法将其换出主存



#### 拓扑排序的原理及特点

> 拓扑排序是一种有向无环图（DAG）的排序算法，将DAG中的所有顶点排序成线性序列。如果DAG中存在环，拓扑排序算法将无法得出结果。
>
> 拓扑排序的实现过程如下：
>
> 1. 从DAG图中选择一个没有前驱（即入度为0）的顶点，并输出该顶点。
> 2. 从图中删除该顶点以及所有以它为起点的有向边。
> 3. 重复步骤1和2，直到图为空或者图中不存在无前驱的顶点为止。
>
> 如果最终输出的顶点数小于图中的顶点数，说明图中存在环，拓扑排序无法完成。
>
> 拓扑排序可以用于判断有向图中是否存在环，以及任务的依赖关系排序等场景。
>
> 1. 只适用于有向无环图：拓扑排序算法只适用于有向无环图(DAG)，因为DAG的节点之间是有方向的，不存在环路，可以进行拓扑排序，而对于存在环路的有向图，拓扑排序算法不适用。
> 2. 输出所有节点：拓扑排序算法会输出DAG的所有节点，而且输出的顺序是满足拓扑排序规则的。
> 3. 拓扑序不唯一：一个DAG可以有多个拓扑序，也就是说，一个DAG的节点可以有多个排序结果。
> 4. 应用广泛：拓扑排序算法在计算机科学中有着广泛的应用，比如任务调度、依赖关系的分析等领域都会用到拓扑排序算法。
> 5. 时间复杂度较高：拓扑排序算法的时间复杂度为O(V+E)，其中V表示节点数，E表示边数。在稠密图中，边数E和节点数V的乘积接近于V^2，所以拓扑排序算法的时间复杂度较高。







